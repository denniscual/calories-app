declare type Maybe<T> = T | null | undefined;
declare type Preserve<T, U> = T extends U ? U : never;
declare type Optionals<T> = Extract<T, null | undefined>;
declare type Defined<T> = T extends undefined ? never : T;
declare type NotNull<T> = T extends null ? never : T;
declare type Thunk<T> = T | (() => T);
declare type _<T> = T extends {} ? {
    [k in keyof T]: T[k];
} : T;
declare type Flags = 's' | 'd' | '';
declare type SetFlag<Old extends Flags, F extends Flags> = Exclude<Old, ''> | F;
declare type UnsetFlag<Old extends Flags, F extends Flags> = Exclude<Old, F> extends never ? '' : Exclude<Old, F>;
declare type ToggleDefault<F extends Flags, D> = Preserve<D, undefined> extends never ? SetFlag<F, 'd'> : UnsetFlag<F, 'd'>;
declare type ResolveFlags<T, F extends Flags> = Preserve<F, 's'> extends never ? Extract<F, 'd'> extends never ? T : Defined<T> : never;
declare type Concat<T, U> = NonNullable<T> & NonNullable<U> extends never ? never : (NonNullable<T> & NonNullable<U>) | Optionals<U>;

declare type ObjectShape = {
    [k: string]: ISchema<any> | Reference;
};
declare type AnyObject = {
    [k: string]: any;
};
declare type TypeFromShape<S extends ObjectShape, C> = {
    [K in keyof S]: S[K] extends ISchema<any, C> ? S[K]['__outputType'] : unknown;
};
declare type DefaultFromShape<Shape extends ObjectShape> = {
    [K in keyof Shape]: Shape[K] extends ISchema<any> ? Shape[K]['__default'] : undefined;
};
declare type ConcatObjectTypes<T extends Maybe<AnyObject>, U extends Maybe<AnyObject>> = ({
    [P in keyof T]: P extends keyof NonNullable<U> ? NonNullable<U>[P] : T[P];
} & U) | Optionals<U>;
declare type PartialDeep<T> = T extends string | number | bigint | boolean | null | undefined | symbol | Date ? T | undefined : T extends Array<infer ArrayType> ? Array<PartialDeep<ArrayType>> : T extends ReadonlyArray<infer ArrayType> ? ReadonlyArray<ArrayType> : {
    [K in keyof T]?: PartialDeep<T[K]>;
};
declare type OptionalKeys<T extends {}> = {
    [k in keyof T]: undefined extends T[k] ? k : never;
}[keyof T];
declare type RequiredKeys<T extends object> = Exclude<keyof T, OptionalKeys<T>>;
declare type MakePartial<T extends object> = {
    [k in OptionalKeys<T> as T[k] extends never ? never : k]?: T[k];
} & {
    [k in RequiredKeys<T> as T[k] extends never ? never : k]: T[k];
};

declare type Params = Record<string, unknown>;
declare class ValidationError extends Error {
    value: any;
    path?: string;
    type?: string;
    errors: string[];
    params?: Params;
    inner: ValidationError[];
    static formatError(message: string | ((params: Params) => string) | unknown, params: Params): any;
    static isError(err: any): err is ValidationError;
    constructor(errorOrErrors: string | ValidationError | readonly ValidationError[], value?: any, field?: string, type?: string);
}

declare type PanicCallback = (err: Error) => void;
declare type NextCallback = (err: ValidationError[] | ValidationError | null) => void;
declare type CreateErrorOptions = {
    path?: string;
    message?: Message<any>;
    params?: ExtraParams;
    type?: string;
};
declare type TestContext<TContext = {}> = {
    path: string;
    options: ValidateOptions<TContext>;
    originalValue: any;
    parent: any;
    from?: Array<{
        schema: ISchema<any, TContext>;
        value: any;
    }>;
    schema: any;
    resolve: <T>(value: T | Reference<T>) => T;
    createError: (params?: CreateErrorOptions) => ValidationError;
};
declare type TestFunction<T = unknown, TContext = {}> = (this: TestContext<TContext>, value: T, context: TestContext<TContext>) => void | boolean | ValidationError | Promise<boolean | ValidationError>;
declare type TestOptions<TSchema extends AnySchema = AnySchema> = {
    value: any;
    path?: string;
    label?: string;
    options: InternalOptions;
    originalValue: any;
    schema: TSchema;
    sync?: boolean;
    spec: MessageParams['spec'];
};
declare type TestConfig<TValue = unknown, TContext = {}> = {
    name?: string;
    message?: Message<any>;
    test: TestFunction<TValue, TContext>;
    params?: ExtraParams;
    exclusive?: boolean;
};
declare type Test = ((opts: TestOptions, panic: PanicCallback, next: NextCallback) => void) & {
    OPTIONS?: TestConfig;
};

declare class ReferenceSet {
    list: Set<unknown>;
    refs: Map<string, Reference>;
    constructor();
    get size(): number;
    describe(): unknown[];
    toArray(): unknown[];
    resolveAll(resolve: (v: unknown) => unknown): unknown[];
    add(value: unknown): void;
    delete(value: unknown): void;
    clone(): ReferenceSet;
    merge(newItems: ReferenceSet, removeItems: ReferenceSet): ReferenceSet;
}

declare type SchemaSpec<TDefault> = {
    coarce: boolean;
    nullable: boolean;
    optional: boolean;
    default?: TDefault | (() => TDefault);
    abortEarly?: boolean;
    strip?: boolean;
    strict?: boolean;
    recursive?: boolean;
    label?: string | undefined;
    meta?: any;
};
declare type SchemaOptions<TType, TDefault> = {
    type: string;
    spec?: Partial<SchemaSpec<TDefault>>;
    check: (value: any) => value is NonNullable<TType>;
};
declare type AnySchema<TType = any, C = AnyObject, D = any, F extends Flags = Flags> = Schema<TType, C, D, F>;
interface CastOptions<C = {}> {
    parent?: any;
    context?: C;
    assert?: boolean;
    stripUnknown?: boolean;
    path?: string;
}
declare type RunTest = (opts: TestOptions, panic: PanicCallback, next: NextCallback) => void;
declare type TestRunOptions = {
    tests: RunTest[];
    args?: TestOptions;
    value: any;
};
interface SchemaRefDescription {
    type: 'ref';
    key: string;
}
interface SchemaInnerTypeDescription extends SchemaDescription {
    innerType?: SchemaFieldDescription;
}
interface SchemaObjectDescription extends SchemaDescription {
    fields: Record<string, SchemaFieldDescription>;
}
interface SchemaLazyDescription {
    type: string;
    label?: string;
    meta: object | undefined;
}
declare type SchemaFieldDescription = SchemaDescription | SchemaRefDescription | SchemaObjectDescription | SchemaInnerTypeDescription | SchemaLazyDescription;
interface SchemaDescription {
    type: string;
    label?: string;
    meta: object | undefined;
    oneOf: unknown[];
    notOneOf: unknown[];
    nullable: boolean;
    optional: boolean;
    tests: Array<{
        name?: string;
        params: ExtraParams | undefined;
    }>;
}
declare abstract class Schema<TType = any, TContext = AnyObject, TDefault = any, TFlags extends Flags = ''> implements ISchema<TType, TContext, TFlags, TDefault> {
    readonly type: string;
    readonly __outputType: ResolveFlags<TType, TFlags>;
    readonly __context: TContext;
    readonly __flags: TFlags;
    readonly __isYupSchema__: boolean;
    readonly __default: TDefault;
    readonly deps: readonly string[];
    tests: Test[];
    transforms: TransformFunction<AnySchema>[];
    private conditions;
    private _mutate?;
    private internalTests;
    protected _whitelist: ReferenceSet;
    protected _blacklist: ReferenceSet;
    protected exclusiveTests: Record<string, boolean>;
    protected _typeCheck: (value: any) => value is NonNullable<TType>;
    spec: SchemaSpec<any>;
    constructor(options: SchemaOptions<TType, any>);
    get _type(): string;
    clone(spec?: Partial<SchemaSpec<any>>): this;
    label(label: string): this;
    meta(): Record<string, unknown> | undefined;
    meta(obj: Record<string, unknown>): this;
    withMutation<T>(fn: (schema: this) => T): T;
    concat(schema: this): this;
    concat(schema: AnySchema): AnySchema;
    isType(v: unknown): v is TType;
    resolve(options: ResolveOptions<TContext>): this;
    protected resolveOptions<T extends InternalOptions<any>>(options: T): T;
    /**
     * Run the configured transform pipeline over an input value.
     */
    cast(value: any, options?: CastOptions<TContext>): this['__outputType'];
    protected _cast(rawValue: any, _options: CastOptions<TContext>): any;
    protected _validate(_value: any, options: InternalOptions<TContext> | undefined, panic: (err: Error, value: unknown) => void, next: (err: ValidationError[], value: unknown) => void): void;
    /**
     * Executes a set of validations, either schema, produced Tests or a nested
     * schema validate result. `args` is intended for schema validation tests, but
     * isn't required to allow the helper to awkwardly be used to run nested array/object
     * validations.
     */
    protected runTests(options: TestRunOptions, panic: (err: Error, value: unknown) => void, next: (errors: ValidationError[], value: unknown) => void): void;
    asNestedTest({ key, index, parent, parentPath, originalParent, options, }: NestedTestConfig): RunTest;
    validate(value: any, options?: ValidateOptions<TContext>): Promise<this['__outputType']>;
    validateSync(value: any, options?: ValidateOptions<TContext>): this['__outputType'];
    isValid(value: any, options?: ValidateOptions<TContext>): Promise<boolean>;
    isValidSync(value: any, options?: ValidateOptions<TContext>): value is this['__outputType'];
    protected _getDefault(): any;
    getDefault(options?: ResolveOptions<TContext>): TDefault;
    default(def: Thunk<any>): any;
    strict(isStrict?: boolean): this;
    protected _isPresent(value: any): boolean;
    protected nullability(nullable: boolean, message?: Message<any>): this;
    protected optionality(optional: boolean, message?: Message<any>): this;
    optional(): any;
    defined(message?: Message<any>): any;
    nullable(): any;
    nonNullable(message?: Message<any>): any;
    required(message?: Message<any>): any;
    notRequired(): any;
    transform(fn: TransformFunction<this>): this;
    /**
     * Adds a test function to the schema's queue of tests.
     * tests can be exclusive or non-exclusive.
     *
     * - exclusive tests, will replace any existing tests of the same name.
     * - non-exclusive: can be stacked
     *
     * If a non-exclusive test is added to a schema with an exclusive test of the same name
     * the exclusive test is removed and further tests of the same name will be stacked.
     *
     * If an exclusive test is added to a schema with non-exclusive tests of the same name
     * the previous tests are removed and further tests of the same name will replace each other.
     */
    test(options: TestConfig<this['__outputType'], TContext>): this;
    test(test: TestFunction<this['__outputType'], TContext>): this;
    test(name: string, test: TestFunction<this['__outputType'], TContext>): this;
    test(name: string, message: Message, test: TestFunction<this['__outputType'], TContext>): this;
    when<U extends ISchema<any> = this>(builder: ConditionBuilder<this, U>): U;
    when<U extends ISchema<any> = this>(keys: string | string[], builder: ConditionBuilder<this, U>): U;
    when<UThen extends ISchema<any> = this, UOtherwise extends ISchema<any> = this>(options: ConditionConfig<this, UThen, UOtherwise>): UThen | UOtherwise;
    when<UThen extends ISchema<any> = this, UOtherwise extends ISchema<any> = this>(keys: string | string[], options: ConditionConfig<this, UThen, UOtherwise>): UThen | UOtherwise;
    typeError(message: Message): this;
    oneOf<U extends TType>(enums: ReadonlyArray<U | Reference>, message?: Message<{
        values: any;
    }>): any;
    notOneOf<U extends TType>(enums: ReadonlyArray<Maybe<U> | Reference>, message?: Message<{
        values: any;
    }>): this;
    strip(strip?: boolean): any;
    /**
     * Return a serialized description of the schema including validations, flags, types etc.
     *
     * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
     */
    describe(options?: ResolveOptions<TContext>): SchemaDescription;
}
interface Schema<TType = any, TContext = AnyObject, TDefault = any, TFlags extends Flags = ''> {
    validateAt(path: string, value: any, options?: ValidateOptions<TContext>): Promise<any>;
    validateSyncAt(path: string, value: any, options?: ValidateOptions<TContext>): any;
    equals: Schema['oneOf'];
    is: Schema['oneOf'];
    not: Schema['notOneOf'];
    nope: Schema['notOneOf'];
}

declare type ReferenceOptions<TValue = unknown> = {
    map?: (value: unknown) => TValue;
};
declare function create$9<TValue = unknown>(key: string, options?: ReferenceOptions<TValue>): Reference<TValue>;
declare class Reference<TValue = unknown> {
    readonly key: string;
    readonly isContext: boolean;
    readonly isValue: boolean;
    readonly isSibling: boolean;
    readonly path: any;
    readonly getter: (data: unknown) => unknown;
    readonly map?: (value: unknown) => TValue;
    readonly __isYupRef: boolean;
    constructor(key: string, options?: ReferenceOptions<TValue>);
    getValue(value: any, parent?: {}, context?: {}): TValue;
    /**
     *
     * @param {*} value
     * @param {Object} options
     * @param {Object=} options.context
     * @param {Object=} options.parent
     */
    cast(value: any, options?: {
        parent?: {};
        context?: {};
    }): TValue;
    resolve(): this;
    describe(): SchemaRefDescription;
    toString(): string;
    static isRef(value: any): value is Reference;
}

declare type ConditionBuilder<T extends ISchema<any, any>, U extends ISchema<any, any> = T> = (values: any[], schema: T, options: ResolveOptions) => U;
declare type ConditionConfig<T extends ISchema<any>, TThen extends ISchema<any, any> = T, TOtherwise extends ISchema<any, any> = T> = {
    is: any | ((...values: any[]) => boolean);
    then?: (schema: T) => TThen;
    otherwise?: (schema: T) => TOtherwise;
};
declare type ResolveOptions<TContext = any> = {
    value?: any;
    parent?: any;
    context?: TContext;
};

interface ISchema<T, C = AnyObject, F extends Flags = any, D = any> {
    __flags: F;
    __context: C;
    __outputType: T;
    __default: D;
    cast(value: any, options?: CastOptions<C>): T;
    validate(value: any, options?: ValidateOptions<C>): Promise<T>;
    asNestedTest(config: NestedTestConfig): Test;
    describe(options?: ResolveOptions<C>): SchemaFieldDescription;
    resolve(options: ResolveOptions<C>): ISchema<T, C, F>;
}
declare type InferType<T extends ISchema<any, any>> = T['__outputType'];
declare type TransformFunction<T extends AnySchema> = (this: T, value: any, originalValue: any, schema: T) => any;
interface Ancester<TContext> {
    schema: ISchema<any, TContext>;
    value: any;
}
interface ValidateOptions<TContext = {}> {
    /**
     * Only validate the input, skipping type casting and transformation. Default - false
     */
    strict?: boolean;
    /**
     * Return from validation methods on the first error rather than after all validations run. Default - true
     */
    abortEarly?: boolean;
    /**
     * Remove unspecified keys from objects. Default - false
     */
    stripUnknown?: boolean;
    /**
     * When false validations will not descend into nested schema (relevant for objects or arrays). Default - true
     */
    recursive?: boolean;
    /**
     * Any context needed for validating schema conditions (see: when())
     */
    context?: TContext;
}
interface InternalOptions<TContext = {}> extends ValidateOptions<TContext> {
    __validating?: boolean;
    originalValue?: any;
    index?: number;
    key?: string;
    parent?: any;
    path?: string;
    sync?: boolean;
    from?: Ancester<TContext>[];
}
interface MessageParams {
    path: string;
    value: any;
    originalValue: any;
    label: string;
    type: string;
    spec: SchemaSpec<any> & Record<string, unknown>;
}
declare type Message<Extra extends Record<string, unknown> = any> = string | ((params: Extra & MessageParams) => unknown) | Record<PropertyKey, unknown>;
declare type ExtraParams = Record<string, unknown>;
interface NestedTestConfig {
    options: InternalOptions<any>;
    parent: any;
    originalParent: any;
    parentPath: string | undefined;
    key?: string;
    index?: number;
}

declare type TypeGuard<TType> = (value: any) => value is NonNullable<TType>;
interface MixedOptions<TType> {
    type?: string;
    check?: TypeGuard<TType>;
}
declare function create$8<TType = any>(spec?: MixedOptions<TType> | TypeGuard<TType>): MixedSchema<TType | undefined, AnyObject, undefined, "">;
declare namespace create$8 {
    var prototype: MixedSchema<any, any, any, any>;
}
declare class MixedSchema<TType = any, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    constructor(spec?: MixedOptions<TType> | TypeGuard<TType>);
}
interface MixedSchema<TType = any, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    default<D extends Maybe<TType>>(def: Thunk<D>): MixedSchema<TType, TContext, D, ToggleDefault<TFlags, D>>;
    concat<IT, IC, ID, IF extends Flags>(schema: MixedSchema<IT, IC, ID, IF>): MixedSchema<Concat<TType, IT>, TContext & IC, ID, TFlags | IF>;
    concat<IT, IC, ID, IF extends Flags>(schema: Schema<IT, IC, ID, IF>): MixedSchema<Concat<TType, IT>, TContext & IC, ID, TFlags | IF>;
    concat(schema: this): this;
    defined(msg?: Message): MixedSchema<Defined<TType>, TContext, TDefault, TFlags>;
    optional(): MixedSchema<TType | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): MixedSchema<NonNullable<TType>, TContext, TDefault, TFlags>;
    notRequired(): MixedSchema<Maybe<TType>, TContext, TDefault, TFlags>;
    nullable(msg?: Message): MixedSchema<TType | null, TContext, TDefault, TFlags>;
    nonNullable(): MixedSchema<Exclude<TType, null>, TContext, TDefault, TFlags>;
    strip(enabled: false): MixedSchema<TType, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): MixedSchema<TType, TContext, TDefault, SetFlag<TFlags, 's'>>;
}

declare function create$7(): BooleanSchema;
declare function create$7<T extends boolean, TContext = AnyObject>(): BooleanSchema<T | undefined, TContext>;
declare namespace create$7 {
    var prototype: BooleanSchema<any, any, any, any>;
}
declare class BooleanSchema<TType extends Maybe<boolean> = boolean | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    constructor();
    isTrue(message?: Message<any> | undefined): BooleanSchema<true | Optionals<TType>, TContext, TFlags>;
    isFalse(message?: Message<any> | undefined): BooleanSchema<false | Optionals<TType>, TContext, TFlags>;
    default<D extends Maybe<TType>>(def: Thunk<D>): BooleanSchema<TType, TContext, D, ToggleDefault<TFlags, D>>;
    defined(msg?: Message): BooleanSchema<Defined<TType>, TContext, TDefault, TFlags>;
    optional(): BooleanSchema<TType | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): BooleanSchema<NonNullable<TType>, TContext, TDefault, TFlags>;
    notRequired(): BooleanSchema<Maybe<TType>, TContext, TDefault, TFlags>;
    nullable(): BooleanSchema<TType | null, TContext, TDefault, TFlags>;
    nonNullable(msg?: Message): BooleanSchema<NotNull<TType>, TContext, TDefault, TFlags>;
    strip(enabled: false): BooleanSchema<TType, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): BooleanSchema<TType, TContext, TDefault, SetFlag<TFlags, 's'>>;
}

interface MixedLocale {
    default?: Message;
    required?: Message;
    oneOf?: Message<{
        values: any;
    }>;
    notOneOf?: Message<{
        values: any;
    }>;
    notNull?: Message;
    notType?: Message;
    defined?: Message;
}
interface StringLocale {
    length?: Message<{
        length: number;
    }>;
    min?: Message<{
        min: number;
    }>;
    max?: Message<{
        max: number;
    }>;
    matches?: Message<{
        regex: RegExp;
    }>;
    email?: Message<{
        regex: RegExp;
    }>;
    url?: Message<{
        regex: RegExp;
    }>;
    uuid?: Message<{
        regex: RegExp;
    }>;
    trim?: Message;
    lowercase?: Message;
    uppercase?: Message;
}
interface NumberLocale {
    min?: Message<{
        min: number;
    }>;
    max?: Message<{
        max: number;
    }>;
    lessThan?: Message<{
        less: number;
    }>;
    moreThan?: Message<{
        more: number;
    }>;
    positive?: Message<{
        more: number;
    }>;
    negative?: Message<{
        less: number;
    }>;
    integer?: Message;
}
interface DateLocale {
    min?: Message<{
        min: Date | string;
    }>;
    max?: Message<{
        max: Date | string;
    }>;
}
interface ObjectLocale {
    noUnknown?: Message;
}
interface ArrayLocale {
    length?: Message<{
        length: number;
    }>;
    min?: Message<{
        min: number;
    }>;
    max?: Message<{
        max: number;
    }>;
}
interface BooleanLocale {
    isValue?: Message;
}
interface LocaleObject {
    mixed?: MixedLocale;
    string?: StringLocale;
    number?: NumberLocale;
    date?: DateLocale;
    boolean?: BooleanLocale;
    object?: ObjectLocale;
    array?: ArrayLocale;
}

declare type MatchOptions = {
    excludeEmptyString?: boolean;
    message: Message<{
        regex: RegExp;
    }>;
    name?: string;
};
declare function create$6(): StringSchema;
declare function create$6<T extends string, TContext = AnyObject>(): StringSchema<T | undefined, TContext>;
declare namespace create$6 {
    var prototype: StringSchema<any, any, any, any>;
}

declare class StringSchema<TType extends Maybe<string> = string | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    constructor();
    protected _isPresent(value: any): boolean;
    length(length: number | Reference<number>, message?: Message<{
        length: number;
    }>): this;
    min(min: number | Reference<number>, message?: Message<{
        min: number;
    }>): this;
    max(max: number | Reference<number>, message?: Message<{
        max: number;
    }>): this;
    matches(regex: RegExp, options?: MatchOptions | MatchOptions['message']): this;
    email(message?: Message<{
        regex: RegExp;
    }>): this;
    url(message?: Message<{
        regex: RegExp;
    }>): this;
    uuid(message?: Message<{
        regex: RegExp;
    }>): this;
    ensure(): StringSchema<NonNullable<TType>>;
    trim(message?: Message<any>): this;
    lowercase(message?: Message<any>): this;
    uppercase(message?: Message<any>): this;
}
interface StringSchema<TType extends Maybe<string> = string | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    default<D extends Maybe<TType>>(def: Thunk<D>): StringSchema<TType, TContext, D, ToggleDefault<TFlags, D>>;
    oneOf<U extends TType>(arrayOfValues: ReadonlyArray<U | Reference>, message?: MixedLocale['oneOf']): StringSchema<U | Optionals<TType>, TContext, TDefault, TFlags>;
    concat<UType extends Maybe<string>, UContext, UDefault, UFlags extends Flags>(schema: StringSchema<UType, UContext, UDefault, UFlags>): StringSchema<Concat<TType, UType>, TContext & UContext, UDefault, TFlags | UFlags>;
    concat(schema: this): this;
    defined(msg?: Message): StringSchema<Defined<TType>, TContext, TDefault, TFlags>;
    optional(): StringSchema<TType | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): StringSchema<NonNullable<TType>, TContext, TDefault, TFlags>;
    notRequired(): StringSchema<Maybe<TType>, TContext, TDefault, TFlags>;
    nullable(msg?: Message<any>): StringSchema<TType | null, TContext, TDefault, TFlags>;
    nonNullable(): StringSchema<NotNull<TType>, TContext, TDefault, TFlags>;
    strip(enabled: false): StringSchema<TType, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): StringSchema<TType, TContext, TDefault, SetFlag<TFlags, 's'>>;
}

declare function create$5(): NumberSchema;
declare function create$5<T extends number, TContext = AnyObject>(): NumberSchema<T | undefined, TContext>;
declare namespace create$5 {
    var prototype: NumberSchema<any, any, any, any>;
}
declare class NumberSchema<TType extends Maybe<number> = number | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    constructor();
    min(min: number | Reference<number>, message?: Message<{
        min: number;
    }>): this;
    max(max: number | Reference<number>, message?: Message<{
        max: number;
    }>): this;
    lessThan(less: number | Reference<number>, message?: Message<{
        less: number;
    }>): this;
    moreThan(more: number | Reference<number>, message?: Message<{
        more: number;
    }>): this;
    positive(msg?: Message<{
        more: number;
    }>): this;
    negative(msg?: Message<{
        less: number;
    }>): this;
    integer(message?: Message<any>): this;
    truncate(): this;
    round(method?: 'ceil' | 'floor' | 'round' | 'trunc'): this;
}
interface NumberSchema<TType extends Maybe<number> = number | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    default<D extends Maybe<TType>>(def: Thunk<D>): NumberSchema<TType, TContext, D, ToggleDefault<TFlags, D>>;
    concat<UType extends Maybe<number>, UContext, UFlags extends Flags, UDefault>(schema: NumberSchema<UType, UContext, UDefault, UFlags>): NumberSchema<Concat<TType, UType>, TContext & UContext, UDefault, TFlags | UFlags>;
    concat(schema: this): this;
    defined(msg?: Message): NumberSchema<Defined<TType>, TContext, TDefault, TFlags>;
    optional(): NumberSchema<TType | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): NumberSchema<NonNullable<TType>, TContext, TDefault, TFlags>;
    notRequired(): NumberSchema<Maybe<TType>, TContext, TDefault, TFlags>;
    nullable(msg?: Message): NumberSchema<TType | null, TContext, TDefault, TFlags>;
    nonNullable(): NumberSchema<NotNull<TType>, TContext, TDefault, TFlags>;
    strip(enabled: false): NumberSchema<TType, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): NumberSchema<TType, TContext, TDefault, SetFlag<TFlags, 's'>>;
}

declare function create$4(): DateSchema;
declare function create$4<T extends Date, TContext = AnyObject>(): DateSchema<T | undefined, TContext>;
declare namespace create$4 {
    var prototype: DateSchema<any, any, any, any>;
    var INVALID_DATE: Date;
}
declare class DateSchema<TType extends Maybe<Date> = Date | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    static INVALID_DATE: Date;
    constructor();
    private prepareParam;
    min(min: unknown | Reference<Date>, message?: Message<{
        min: string | Date;
    }>): this;
    max(max: unknown | Reference, message?: Message<{
        max: string | Date;
    }>): this;
}
interface DateSchema<TType extends Maybe<Date>, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    default<D extends Maybe<TType>>(def: Thunk<D>): DateSchema<TType, TContext, D, ToggleDefault<TFlags, D>>;
    concat<TOther extends DateSchema<any, any>>(schema: TOther): TOther;
    defined(msg?: Message): DateSchema<Defined<TType>, TContext, TDefault, TFlags>;
    optional(): DateSchema<TType | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): DateSchema<NonNullable<TType>, TContext, TDefault, TFlags>;
    notRequired(): DateSchema<Maybe<TType>, TContext, TDefault, TFlags>;
    nullable(msg?: Message): DateSchema<TType | null, TContext, TDefault, TFlags>;
    nonNullable(): DateSchema<NotNull<TType>, TContext, TDefault, TFlags>;
    strip(enabled: false): DateSchema<TType, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): DateSchema<TType, TContext, TDefault, SetFlag<TFlags, 's'>>;
}

declare type MakeKeysOptional<T> = T extends AnyObject ? _<MakePartial<T>> : T;
declare type Shape<T extends Maybe<AnyObject>, C = AnyObject> = {
    [field in keyof T]: ISchema<T[field], C> | Reference;
};
declare type ObjectSchemaSpec = SchemaSpec<any> & {
    noUnknown?: boolean;
};
declare function create$3<C = AnyObject, S extends ObjectShape = {}>(spec?: S): ObjectSchema<_<TypeFromShape<S, C>>, C, _<DefaultFromShape<S>>, "">;
declare namespace create$3 {
    var prototype: ObjectSchema<any, any, any, any>;
}
interface ObjectSchema<TIn extends Maybe<AnyObject>, TContext = AnyObject, TDefault = any, TFlags extends Flags = ''> extends Schema<MakeKeysOptional<TIn>, TContext, TDefault, TFlags> {
    default<D extends Maybe<AnyObject>>(def: Thunk<D>): ObjectSchema<TIn, TContext, D, ToggleDefault<TFlags, 'd'>>;
    defined(msg?: Message): ObjectSchema<Defined<TIn>, TContext, TDefault, TFlags>;
    optional(): ObjectSchema<TIn | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): ObjectSchema<NonNullable<TIn>, TContext, TDefault, TFlags>;
    notRequired(): ObjectSchema<Maybe<TIn>, TContext, TDefault, TFlags>;
    nullable(msg?: Message): ObjectSchema<TIn | null, TContext, TDefault, TFlags>;
    nonNullable(): ObjectSchema<NotNull<TIn>, TContext, TDefault, TFlags>;
    strip(enabled: false): ObjectSchema<TIn, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): ObjectSchema<TIn, TContext, TDefault, SetFlag<TFlags, 's'>>;
}
declare class ObjectSchema<TIn extends Maybe<AnyObject>, TContext = AnyObject, TDefault = any, TFlags extends Flags = ''> extends Schema<MakeKeysOptional<TIn>, TContext, TDefault, TFlags> {
    fields: Shape<NonNullable<TIn>, TContext>;
    spec: ObjectSchemaSpec;
    private _sortErrors;
    private _nodes;
    private _excludedEdges;
    constructor(spec?: Shape<TIn, TContext>);
    protected _cast(_value: any, options?: InternalOptions<TContext>): any;
    protected _validate(_value: any, options: InternalOptions<TContext> | undefined, panic: (err: Error, value: unknown) => void, next: (err: ValidationError[], value: unknown) => void): void;
    clone(spec?: ObjectSchemaSpec): this;
    concat<IIn, IC, ID, IF extends Flags>(schema: ObjectSchema<IIn, IC, ID, IF>): ObjectSchema<ConcatObjectTypes<TIn, IIn>, TContext & IC, Extract<IF, 'd'> extends never ? _<ConcatObjectTypes<TDefault, ID>> : ID, TFlags | IF>;
    concat(schema: this): this;
    protected _getDefault(): any;
    private setFields;
    shape<U extends ObjectShape>(additions: U, excludes?: readonly [string, string][]): ObjectSchema<_<{ [P in keyof TIn]: P extends keyof U ? TypeFromShape<U, TContext>[P] : TIn[P]; } & TypeFromShape<U, TContext>> | _<Extract<TIn, null | undefined>>, TContext, Extract<TFlags, "d"> extends never ? _<TDefault & DefaultFromShape<U>> : TDefault, TFlags>;
    partial(): ObjectSchema<Partial<TIn>, TContext, TDefault, TFlags>;
    deepPartial(): ObjectSchema<PartialDeep<TIn>, TContext, TDefault, TFlags>;
    pick<TKey extends keyof TIn>(keys: readonly TKey[]): ObjectSchema<{ [K in TKey]: TIn[K]; }, TContext, TDefault, TFlags>;
    omit<TKey extends keyof TIn>(keys: readonly TKey[]): ObjectSchema<Omit<TIn, TKey>, TContext, TDefault, TFlags>;
    from(from: string, to: keyof TIn, alias?: boolean): this;
    /** Parse an input JSON string to an object */
    json(): this;
    noUnknown(message?: Message): this;
    noUnknown(noAllow: boolean, message?: Message): this;
    unknown(allow?: boolean, message?: Message<any>): this;
    transformKeys(fn: (key: string) => string): this;
    camelCase(): this;
    snakeCase(): this;
    constantCase(): this;
    describe(options?: ResolveOptions<TContext>): SchemaObjectDescription;
}

declare type InnerType<T> = T extends Array<infer I> ? I : never;
declare type RejectorFn = (value: any, index: number, array: readonly any[]) => boolean;
declare function create$2<C = AnyObject, T = any>(type?: ISchema<T, C>): ArraySchema<T[] | undefined, C, undefined, "">;
declare namespace create$2 {
    var prototype: ArraySchema<any, any, any, any>;
}
declare class ArraySchema<TIn extends any[] | null | undefined, TContext, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TIn, TContext, TDefault, TFlags> {
    readonly innerType?: ISchema<InnerType<TIn>, TContext>;
    constructor(type?: ISchema<InnerType<TIn>, TContext>);
    protected _cast(_value: any, _opts: InternalOptions<TContext>): any;
    protected _validate(_value: any, options: InternalOptions<TContext> | undefined, panic: (err: Error, value: unknown) => void, next: (err: ValidationError[], value: unknown) => void): void;
    clone(spec?: SchemaSpec<any>): this;
    /** Parse an input JSON string to an object */
    json(): this;
    concat<IIn extends Maybe<any[]>, IC, ID, IF extends Flags>(schema: ArraySchema<IIn, IC, ID, IF>): ArraySchema<Concat<TIn, IIn>, TContext & IC, Extract<IF, 'd'> extends never ? TDefault : ID, TFlags | IF>;
    concat(schema: this): this;
    of<U>(schema: ISchema<U, TContext>): ArraySchema<U[] | Optionals<TIn>, TContext, TFlags>;
    length(length: number | Reference<number>, message?: Message<{
        length: number;
    }>): this;
    min(min: number | Reference<number>, message?: Message<{
        min: number;
    }>): this;
    max(max: number | Reference<number>, message?: Message<{
        max: number;
    }>): this;
    ensure(): ArraySchema<TIn, TContext, TIn, ToggleDefault<TFlags, TIn>>;
    compact(rejector?: RejectorFn): this;
    describe(options?: ResolveOptions<TContext>): SchemaInnerTypeDescription;
}
interface ArraySchema<TIn extends any[] | null | undefined, TContext, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TIn, TContext, TDefault, TFlags> {
    default<D extends Maybe<TIn>>(def: Thunk<D>): ArraySchema<TIn, TContext, D, ToggleDefault<TFlags, D>>;
    defined(msg?: Message): ArraySchema<Defined<TIn>, TContext, TDefault, TFlags>;
    optional(): ArraySchema<TIn | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): ArraySchema<NonNullable<TIn>, TContext, TDefault, TFlags>;
    notRequired(): ArraySchema<Maybe<TIn>, TContext, TDefault, TFlags>;
    nullable(msg?: Message): ArraySchema<TIn | null, TContext, TDefault, TFlags>;
    nonNullable(): ArraySchema<NotNull<TIn>, TContext, TDefault, TFlags>;
    strip(enabled: false): ArraySchema<TIn, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): ArraySchema<TIn, TContext, TDefault, SetFlag<TFlags, 's'>>;
}

declare type AnyTuple = [unknown, ...unknown[]];
declare function create$1<T extends AnyTuple>(schemas: {
    [K in keyof T]: ISchema<T[K]>;
}): TupleSchema<T | undefined, AnyObject, undefined, "">;
declare namespace create$1 {
    var prototype: TupleSchema<any, any, any, any>;
}
interface TupleSchemaSpec<T> extends SchemaSpec<any> {
    types: T extends any[] ? {
        [K in keyof T]: ISchema<T[K]>;
    } : never;
}
interface TupleSchema<TType extends Maybe<AnyTuple> = AnyTuple | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    default<D extends Maybe<TType>>(def: Thunk<D>): TupleSchema<TType, TContext, D, ToggleDefault<TFlags, D>>;
    concat<TOther extends TupleSchema<any, any>>(schema: TOther): TOther;
    defined(msg?: Message): TupleSchema<Defined<TType>, TContext, TDefault, TFlags>;
    optional(): TupleSchema<TType | undefined, TContext, TDefault, TFlags>;
    required(msg?: Message): TupleSchema<NonNullable<TType>, TContext, TDefault, TFlags>;
    notRequired(): TupleSchema<Maybe<TType>, TContext, TDefault, TFlags>;
    nullable(msg?: Message): TupleSchema<TType | null, TContext, TDefault, TFlags>;
    nonNullable(): TupleSchema<NotNull<TType>, TContext, TDefault, TFlags>;
    strip(enabled: false): TupleSchema<TType, TContext, TDefault, UnsetFlag<TFlags, 's'>>;
    strip(enabled?: true): TupleSchema<TType, TContext, TDefault, SetFlag<TFlags, 's'>>;
}
declare class TupleSchema<TType extends Maybe<AnyTuple> = AnyTuple | undefined, TContext = AnyObject, TDefault = undefined, TFlags extends Flags = ''> extends Schema<TType, TContext, TDefault, TFlags> {
    spec: TupleSchemaSpec<TType>;
    constructor(schemas: [ISchema<any>, ...ISchema<any>[]]);
    protected _cast(inputValue: any, options: InternalOptions<TContext>): any;
    protected _validate(_value: any, options: InternalOptions<TContext> | undefined, panic: (err: Error, value: unknown) => void, next: (err: ValidationError[], value: unknown) => void): void;
}

declare type LazyBuilder<T, TContext = AnyObject, TDefault = any, TFlags extends Flags = any> = (value: any, options: ResolveOptions) => ISchema<T, TContext, TFlags, TDefault>;
declare function create<T, TContext = AnyObject, TFlags extends Flags = any, TDefault = any>(builder: LazyBuilder<T, TContext, TDefault, TFlags>): Lazy<T, TContext, TDefault, TFlags>;
interface LazySpec {
    meta: Record<string, unknown> | undefined;
}
declare class Lazy<T, TContext = AnyObject, TDefault = any, TFlags extends Flags = any> implements ISchema<T, TContext, TFlags, TDefault> {
    private builder;
    type: "lazy";
    __isYupSchema__: boolean;
    readonly __outputType: T;
    readonly __context: TContext;
    readonly __flags: TFlags;
    readonly __default: TDefault;
    spec: LazySpec;
    constructor(builder: LazyBuilder<T, TContext, TDefault, TFlags>);
    clone(): Lazy<T, TContext, TDefault, TFlags>;
    private _resolve;
    resolve(options: ResolveOptions<TContext>): Schema<T, TContext, TDefault, TFlags>;
    cast(value: any, options?: CastOptions<TContext>): T;
    asNestedTest(options: NestedTestConfig): RunTest;
    validate(value: any, options?: ValidateOptions<TContext>): Promise<T>;
    validateSync(value: any, options?: ValidateOptions<TContext>): T;
    validateAt(path: string, value: any, options?: ValidateOptions<TContext>): Promise<any>;
    validateSyncAt(path: string, value: any, options?: ValidateOptions<TContext>): any;
    isValid(value: any, options?: ValidateOptions<TContext>): Promise<boolean>;
    isValidSync(value: any, options?: ValidateOptions<TContext>): boolean;
    describe(options?: ResolveOptions<TContext>): SchemaLazyDescription | SchemaFieldDescription;
    meta(): Record<string, unknown> | undefined;
    meta(obj: Record<string, unknown>): Lazy<T, TContext, TDefault, TFlags>;
}

declare function getIn<C = any>(schema: any, path: string, value?: any, context?: C): {
    parent: any;
    parentPath: string;
    schema: any;
};
declare const reach: (obj: any, path: string, value?: any, context?: any) => any;

declare const isSchema: (obj: any) => obj is ISchema<any, AnyObject, any, any>;

declare function setLocale(custom: LocaleObject): void;

declare function addMethod<T extends AnySchema>(schemaType: (...arg: any[]) => T, name: string, fn: (this: T, ...args: any[]) => T): void;
declare function addMethod<T extends new (...args: any) => AnySchema>(schemaType: T, name: string, fn: (this: InstanceType<T>, ...args: any[]) => InstanceType<T>): void;
declare type AnyObjectSchema = ObjectSchema<any, any, any, any>;

export { AnyObject, AnyObjectSchema, AnySchema, ArraySchema, InferType as Asserts, BooleanSchema, CreateErrorOptions, DateSchema, InferType, MixedOptions, MixedSchema, NumberSchema, ObjectSchema, Schema, StringSchema, TestConfig, TestContext, TestFunction, TestOptions, TupleSchema, TypeGuard, ValidationError, addMethod, create$2 as array, create$7 as bool, create$7 as boolean, create$4 as date, getIn, isSchema, create as lazy, create$8 as mixed, create$5 as number, create$3 as object, reach, create$9 as ref, setLocale, create$6 as string, create$1 as tuple };
